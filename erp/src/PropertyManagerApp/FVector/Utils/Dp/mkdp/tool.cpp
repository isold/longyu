#include "tool.h"


template<class StructDesc>
std::string writeTitle(const StructDesc &st)
{
	std::stringstream ss(std::ios::out);
    ss << "///////////////////////////\n"; 
    ss << "/////////////////// " << st.name_;
    ss << "///////////////////////////\n";
    ss.flush();
    return ss.str();
}

template<class StructDesc,class MemberDesc>
std::string writeCtor(const StructDesc &st)
{
	std::vector<const MemberDesc*> construct_members;

	size_t i = 0;
	for (; i<st.members_.size(); ++i)
	{
		const MemberDesc &m = st.members_[i];
		if (!m.def_.empty())
			construct_members.push_back(&m);
	}

	std::stringstream ss(std::ios::out);

	// void struct_name::struct_name(void)
	ss << st.name_ << "::" << st.name_ <<"(void)\n";

	if (!construct_members.empty())
	{
		//		: first_member(default_value)
		const MemberDesc *m = construct_members[0];
		ss << "\t : " << m->name_ << "(" << m->def_ << ")";

		for (i=1; i<construct_members.size(); ++i)
		{
			m = construct_members[i];
			ss << ",\n\t   " << m->name_ << "(" << m->def_ << ")";
		}
        ss << "\n";
	}

	ss << "{\n}\n\n\n";																				
	ss.flush();
	return ss.str();
}



bool parse(const std::string &org,std::string &results,std::string &somes)
{
	results.clear();

	std::vector<DStructDesc> dsts;
	dparse(org.c_str(),dsts);

	if (dsts.empty())
		return false;

	size_t i = 0;	
    std::string title;
    for (; i<dsts.size(); ++i)
	{
        title.clear();

		DStructDesc &st = dsts[i];
        title = writeTitle(st);

        results += title;
        results += writeCtor<DStructDesc,DMemberDesc>(st);
		results += dwrite_loader(st);
		results += dwrite_saver(st);

        somes += title;
		somes += dwrite_some_loader(st);
		somes += dwrite_some_saver(st);
	}


	std::vector<FStructDesc> fsts;
	fparse(org.c_str(),fsts);
	for (i=0; i<fsts.size(); ++i)
	{
		FStructDesc &st = fsts[i];
        
        results += writeTitle(st);
		results += writeCtor<FStructDesc,FMemberDesc>(st);
		results += fwrite_loader(st);
		results += fwrite_saver(st);
	}

	return true;
}

bool parse(const char *path,std::string &org,std::string &results,std::string &somes)
{
	std::ifstream fs(path);
	if (!fs.is_open())
		return false;

	std::ostringstream ss;
	ss << fs.rdbuf();
	ss.flush();

	org = ss.str();

	return parse(org,results,somes);

}

#define DP_TOOL_VERSION "1.1.1.0"
#define DP_TOOL_DECLARATION "//////////////////\n// Generated by makedp(1.0.0.0)\n////////////////\n\n" 

void printVersion(void)
{
	printf("%s\n",DP_TOOL_VERSION);
}

bool makeDp(const char *src,char *inl,char *cpp)
{
	std::string org,results,somes;
	if (!parse(src,org,results,somes))
		return false;

	std::ofstream cppFile(cpp);
	cppFile << DP_TOOL_DECLARATION;
    char *name = strrchr((char*)src,'/');
    if (name == NULL)
        name = strrchr((char*)src,'\\');
    if (name == NULL)
        name = (char*)src;
    else
        ++name;
    cppFile << "#include \"" << name << "\"\n\n\n" ;

	cppFile << results;

	std::ofstream inlFile(inl);
	inlFile << DP_TOOL_DECLARATION;
	inlFile << somes;
	return true;
}


bool makeDp(const char *src)
{    
	char inl[260];
	strcpy(inl,src);

	char cpp[260];
	strcpy(cpp,src);

	char *dot = strrchr(inl,'.');
	if (dot == NULL)
	{
		strcat(inl,".inl");
		strcat(cpp,".cpp");
	}
	else
	{
		strcpy(dot,".inl");
		strcpy(cpp+(dot-inl),".cpp");
	}

	return makeDp(src,inl,cpp);
}
 
#include "../String.h"
int main(int argc,char *argv[])
{

    switch (argc)
    {
    case 1:   
        printVersion(); 
        break;
    case 2:
        if (!makeDp(argv[1]))
            printf("Bad file format!\n");
        break;
    case 4:
        if (!makeDp(argv[1],argv[2],argv[3]))
            printf("Bad file format!\n");
        break;
    default:
        printf("Error number of arguments\n");
        break;
    }

    return 0;
} 