//////////////////
// Generated by makedp(1.0.0.0)
////////////////

///////////////////////////
/////////////////// Person///////////////////////////
template <Dp::SizeType _Sz>
bool load_some(Dp::Reader &r,Dp::Array<Person,_Sz> &elems) 
{
	Dp::SizeType count; r >> count;
	Dp::Array<uint8_t,32> flags; r >> flags;

	for (Dp::SizeType i=0; i<count; ++i)
	{
		Person elem;

		Dp::SizeType structLen; r >> structLen;
		Dp::SizeType structEnd = r.cursor() + structLen;

		//----- id -----
		r >> elem.id;
		//----- sex -----
		r >> elem.sex;
		//----- nick -----
		r >> elem.nick;
		//----- address -----
		r >> elem.address;
		if (!r.ok()) return false;

		for (Dp::SizeType j=0; j<flags.size(); ++j) 
		{
			uint8_t mid = Dp::memberId(flags[j]);
			uint8_t msize  = Dp::memberSize((flags[j]));

			switch (mid)
			{
			//----- stuv -----
			case 21: r >> elem.stuv; break;
			//----- memo -----
			case 1: r >> elem.memo; break;
			//----- data -----
			case 2: r >> elem.data; break;
			//----- he -----
			case 10: r >> elem.he; break;
			//----- hafasf -----
			case 11: r >> elem.hafasf; break;
			default:
				switch (msize)
				{
				case Dp::TypesEnum::size_8: r.skip(1); break;
				case Dp::TypesEnum::size_16:r.skip(2); break;
				case Dp::TypesEnum::size_32:r.skip(4); break;
				case Dp::TypesEnum::size_64:r.skip(8); break;
				case Dp::TypesEnum::size_array: { Dp::SizeType as; r >> as; r.skip(as); } break;
				default:break;
				}
				break;
			}
		}

		if (!r.ok() || r.cursor()!=structEnd) 
			return false;
		elems.push_back(elem);
	}
	return true;
}
template <uint32_t _Sz>
void save_some(Dp::Writer &w,const Dp::Array<Person,_Sz> &elems) 
{
	w << elems.size();

	const uint8_t flags[] = {
			Dp::makeMemberFlag(21,	Dp::TypesEnum::size_32),
			Dp::makeMemberFlag(1,	Dp::TypesEnum::size_array),
			Dp::makeMemberFlag(2,	Dp::TypesEnum::size_array),
			Dp::makeMemberFlag(10,	Dp::TypesEnum::size_array),
			Dp::makeMemberFlag(11,	Dp::TypesEnum::size_array)
		};
	w << (Dp::SizeType)sizeof(flags);  w.put(flags,sizeof(flags));

	for (size_t i=0; i<elems.size(); ++i)
	{
		const Person &elem = elems[i];

		Dp::SizeType start = w.cursor();
		w.skip(sizeof(Dp::SizeType));

		//----- elem.id -----
		w << elem.id;
		//----- elem.sex -----
		w << elem.sex;
		//----- elem.nick -----
		w << elem.nick;
		//----- elem.address -----
		w << elem.address;
		//----- elem.stuv -----
		w << elem.stuv;
		//----- elem.memo -----
		w << elem.memo;
		//----- elem.data -----
		w << elem.data;
		//----- elem.he -----
		w << elem.he;
		//----- elem.hafasf -----
		w << elem.hafasf;
		Dp::SizeType len = w.cursor() - start - sizeof(Dp::SizeType);
		w.set(start,len);
	}
}

///////////////////////////
/////////////////// Person1///////////////////////////
template <Dp::SizeType _Sz>
bool load_some(Dp::Reader &r,Dp::Array<Person1,_Sz> &elems) 
{
	Dp::SizeType count; r >> count;
	Dp::Array<uint8_t,32> flags; r >> flags;

	for (Dp::SizeType i=0; i<count; ++i)
	{
		Person1 elem;

		Dp::SizeType structLen; r >> structLen;
		Dp::SizeType structEnd = r.cursor() + structLen;

		//----- id -----
		r >> elem.id;
		//----- sex -----
		r >> elem.sex;
		//----- nick -----
		r >> elem.nick;
		//----- address -----
		r >> elem.address;
		if (!r.ok()) return false;

		for (Dp::SizeType j=0; j<flags.size(); ++j) 
		{
			uint8_t mid = Dp::memberId(flags[j]);
			uint8_t msize  = Dp::memberSize((flags[j]));

			switch (mid)
			{
			//----- memo -----
			case 1: r >> elem.memo; break;
			//----- sdata -----
			case 3: r >> elem.sdata; break;
			//----- s11data -----
			case 4: r >> elem.s11data; break;
			//----- hdata -----
			case 5: r >> elem.hdata; break;
			//----- he -----
			case 10: r >> elem.he; break;
			//----- hafasf -----
			case 11: r >> elem.hafasf; break;
			default:
				switch (msize)
				{
				case Dp::TypesEnum::size_8: r.skip(1); break;
				case Dp::TypesEnum::size_16:r.skip(2); break;
				case Dp::TypesEnum::size_32:r.skip(4); break;
				case Dp::TypesEnum::size_64:r.skip(8); break;
				case Dp::TypesEnum::size_array: { Dp::SizeType as; r >> as; r.skip(as); } break;
				default:break;
				}
				break;
			}
		}

		if (!r.ok() || r.cursor()!=structEnd) 
			return false;
		elems.push_back(elem);
	}
	return true;
}
template <uint32_t _Sz>
void save_some(Dp::Writer &w,const Dp::Array<Person1,_Sz> &elems) 
{
	w << elems.size();

	const uint8_t flags[] = {
			Dp::makeMemberFlag(1,	Dp::TypesEnum::size_array),
			Dp::makeMemberFlag(3,	Dp::TypesEnum::size_array),
			Dp::makeMemberFlag(4,	Dp::TypesEnum::size_64),
			Dp::makeMemberFlag(5,	Dp::TypesEnum::size_64),
			Dp::makeMemberFlag(10,	Dp::TypesEnum::size_array),
			Dp::makeMemberFlag(11,	Dp::TypesEnum::size_array)
		};
	w << (Dp::SizeType)sizeof(flags);  w.put(flags,sizeof(flags));

	for (size_t i=0; i<elems.size(); ++i)
	{
		const Person1 &elem = elems[i];

		Dp::SizeType start = w.cursor();
		w.skip(sizeof(Dp::SizeType));

		//----- elem.id -----
		w << elem.id;
		//----- elem.sex -----
		w << elem.sex;
		//----- elem.nick -----
		w << elem.nick;
		//----- elem.address -----
		w << elem.address;
		//----- elem.memo -----
		w << elem.memo;
		//----- elem.sdata -----
		w << elem.sdata;
		//----- elem.s11data -----
		w << elem.s11data;
		//----- elem.hdata -----
		w << elem.hdata;
		//----- elem.he -----
		w << elem.he;
		//----- elem.hafasf -----
		w << elem.hafasf;
		Dp::SizeType len = w.cursor() - start - sizeof(Dp::SizeType);
		w.set(start,len);
	}
}

